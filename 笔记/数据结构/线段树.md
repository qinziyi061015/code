```cpp
这是一棵“迭代式（非递归）”线段树，支持：

点更新：把位置 p 的值更新为 max(原值, v)
区间查询：查询闭区间 [l, r] 的最大值
核心要点如下：

存储布局与初始化

把叶子放在数组 t 的区间 [SZ, SZ + n - 1]，其中 SZ 是不小于 n 的最小 2 的幂。
内部结点放在 [1, SZ - 1]，每个内部结点维护它两个子结点的 merge 结果（这里是 max）。
init(n):
计算 SZ 为最小 2^k ≥ n
t.resize(2*SZ)，用 0 初始化（这里 0 作为“最大值”的幺元，意味着所有值非负；若可能为负，应改用 -INF）
点更新 point_max(p, v)

把叶子 i = p + SZ 更新为 t[i] = max(t[i], v)，表示“取更大值”（不是覆盖赋值）
然后一路向上 i >>= 1，上推：t[i] = max(t[i<<1], t[i<<1|1])
复杂度 O(log n)
注意：这是“点 chmax”，如果你需要“点赋值”，应改成 t[i] = v，并在上推时不再与旧值取 max
区间查询 range_max(l, r)（闭区间）

如果 l > r，返回 0（与上面的幺元一致）
把查询区间映射到叶子段：L = l + SZ，R = r + SZ
迭代法的标准写法：
当 L 是右子（L&1）时，t[L] 完全落在当前区间里，先纳入答案 res = max(res, t[L])，然后 L++ 跨过它
当 R 是左子（!(R&1)）时，t[R] 完全落在当前区间里，纳入答案 res = max(res, t[R])，然后 R-- 跨过它
接着 L >>= 1, R >>= 1 同时上移到父结点
循环直到 L > R
复杂度 O(log n)
这是“最小覆盖”的思想：用尽量少的节点完全覆盖 [l, r]，每次只把完全在区间内的节点并入答案
下标与边界

p、l、r 都是 0-based，且 0 ≤ p,l,r < n
t[0] 不用（根是 t[1]），叶子从 t[SZ] 开始；这是常见的数组线段树布局
幺元与取值范围

本模板用 0 作为最大值查询的幺元，适用于“值 ≥ 0”的场景（比如这里存的是“最大右端点”，未出现时为 0）
如果你的值可能为负，应把初值与返回的“空区间值”改成 -INF，并相应地把类型换成 long long 等
可拓展性

想做最小值查询：把 max 改成 min，并把幺元改成 +INF（你文件里对应的 SegMin 就是这样）
想支持区间加、区间赋值等，需要引入“懒标记”的线段树（lazy propagation）
想要“半开区间 [l, r) 查询”，可以把入参约定为 [l, r) 并在调用时用 r-1 传给这个模板，或改写查询循环为半开风格
小示例（逻辑流）

n=5 → SZ=8 → 叶子在 t[8..12]
point_max(2, 7): 更新 t[10]=max(t[10],7)，然后更新 t[5], t[2], t[1]
range_max(1, 3): L=9, R=11
L&1 → 吃 t[9]，L=10；R&1==0 不成立（11 是右子）
L=10, R=11 → R 是左子不成立，L、R 同时上移 → L=5, R=5
L<=R 且 L 是右子 → 吃 t[5]，L=6；上移结束
这套迭代写法相比递归更紧凑且常数小，适合竞赛中频繁查询/更新的场合。


struct SegMax
{
	int n, SZ;
	vector<int> t;
	void init(int n_)
	{
		n = n_;
		SZ = 1;
		while (SZ < n)
			SZ <<= 1;
		t.assign(2 * SZ, 0);
	}
	void point_max(int p, int v)
	{
		int i = p + SZ;
		t[i] = max(t[i], v);
		for (i >>= 1; i; i >>= 1)
			t[i] = max(t[i << 1], t[i << 1 | 1]);
	}
	int range_max(int l, int r)
	{
		if (l > r)
			return 0;
		int L = l + SZ, R = r + SZ, res = 0;
		while (L <= R)
		{
			if (L & 1)
				res = max(res, t[L++]);
			if (!(R & 1))
				res = max(res, t[R--]);
			L >>= 1;
			R >>= 1;
		}
		return res;
	}
};
struct SegMin
{
	int n, SZ;
	vector<int> t;
	const int INF = 1e9;
	void init(int n_)
	{
		n = n_;
		SZ = 1;
		while (SZ < n)
			SZ <<= 1;
		t.assign(2 * SZ, INF);
	}
	void point_min(int p, int v)
	{
		int i = p + SZ;
		t[i] = min(t[i], v);
		for (i >>= 1; i; i >>= 1)
			t[i] = min(t[i << 1], t[i << 1 | 1]);
	}
	int range_min(int l, int r)
	{
		if (l > r)
			return INF;
		int L = l + SZ, R = r + SZ, res = INF;
		while (L <= R)
		{
			if (L & 1)
				res = min(res, t[L++]);
			if (!(R & 1))
				res = min(res, t[R--]);
			L >>= 1;
			R >>= 1;
		}
		return res;
	}
};
```