```if(binary_search(v.begin(), v.end(), make_pair(v[i].first, v[j].second)) && binary_search(v.begin(), v.end(), make_pair(v[j].first, v[i].second)))```
拆出来可以发现*binary_search*该函数会返回一个 bool 类型值，如果 binary_search() 函数在 [first, last) 区域内成功找到和 val 相等的元素，则返回 true；反之则返回 false。  

```using mint = atcoder::modint998244353;mint m_inv = mint(1) / m;```
对于atc，小数直接除  

```vector dp(k + 1, vector(n + 1, mint(0)));```
```cout << dp.back().back().val() << endl;```vector的最后一个元素叫做```v.back()```

```cpp
void merge(int x, int y) {
  int xx = find(x), yy = find(y);
  if (size[xx] < size[yy]) swap(xx, yy);
  fa[yy] = xx;
  size[xx] += size[yy];
}
```
这叫树上启发式合并dsu on tree  
```cpp
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
} 
```  

```cpp
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;

int main() {
    int N, Q;
    cin >> N >> Q;

    // サイズ N の Union-Find を宣言
    atcoder::dsu uf(N);

    // クエリ処理
    for (int i = 0; i < Q; ++i) {
        int type, u, v;
        cin >> type >> u >> v;
        if (type == 1) 
            cout << (uf.same(u, v) ? 1 : 0) << endl;
        else
            uf.merge(u, v);
    }
}
```

atc dsu示例  
使用简洁语言完成atcdsu模板  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct UnionFind {
    vector<int> par;

    UnionFind() { }
    UnionFind(int n) : par(n, -1) { }
    void init(int n) { par.assign(n, -1); }
    
    int root(int x) {
        if (par[x] < 0) return x;
        else return par[x] = root(par[x]);
    }
    
    bool issame(int x, int y) {
        return root(x) == root(y);
    }
    
    bool merge(int x, int y) {
        x = root(x); y = root(y);
        if (x == y) return false;
        if (par[x] > par[y]) swap(x, y); // merge technique
        par[x] += par[y];
        par[y] = x;
        return true;
    }
    
    int size(int x) {
        return -par[root(x)];
    }
};
```


atc 树状数组模板
```cpp
template <class Abel> struct BIT {
    Abel UNITY_SUM = 0;
    vector<Abel> dat;
    
    // [0, n)
    BIT(int n, Abel unity = 0) : UNITY_SUM(unity), dat(n, unity) { }
    void init(int n) {
        dat.assign(n, UNITY_SUM);
    }
    
    // a is 0-indexed
    inline void add(int a, Abel x) {
        for (int i = a; i < (int)dat.size(); i |= i + 1)
            dat[i] = dat[i] + x;
    }
    
    // [0, a), a is 0-indexed
    inline Abel sum(int a) {
        Abel res = UNITY_SUM;
        for (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1)
            res = res + dat[i];
        return res;
    }
    
    // [a, b), a and b are 0-indexed
    inline Abel sum(int a, int b) {
        return sum(b) - sum(a);
    }
    
    // debug
    void print() {
        for (int i = 0; i < (int)dat.size(); ++i)
            cout << sum(i, i + 1) << ",";
        cout << endl;
    }
};

```
可以替代的树状数组模板  

