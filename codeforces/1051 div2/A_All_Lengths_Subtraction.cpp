// A. All Lengths Subtraction — 通过解（中文注释）
// 思路（用“是否存在全正窗口”的贪心可行性检查）：
// 我们必须按 k = 1..n 依次恰好执行 n 次操作：每次选择一个长度为 k 的子数组，把其中每个元素减 1，最终希望把整个数组变为 0。
//
// 设 r 初始等于排列 p，把 r[i] 理解为“位置 i 还需要被减的次数”。
// 按从大到小的顺序处理 k（k = n..1）。在第 k 步，必须能找到一个长度为 k 的窗口，使得该窗口内每个数都 ≥ 1；
// 否则即使整体有解，此时这一步也无处落子（不存在全为正的长度 k 的块），因此不可能完成。
// 如果存在这样的窗口，就把该窗口内所有元素减 1，这会让这些位置的“剩余需求”各减 1，同时不会破坏之后更小长度的可行性
// （更小的 k 只需要存在一个更短的“全正”窗口。在我们在全正窗口上减 1 之后，这样的窗口不比之前更难出现）。
//
// 算法：
// - 对 k 从 n 到 1：枚举所有长度为 k 的窗口，找到任意一个在 r 中所有元素都 > 0 的窗口；若找到就对该窗口统一减 1。
// - 若某个 k 找不到这样的窗口，则输出 NO；若全部 k 都能找到并执行完，则输出 YES。
//
// 正确性直觉：
// - 必要性：任意可行方案在进行长度为 k 的那一步时，必然存在某个长度为 k 的全正窗口（这一步必须在这些位置减 1）。
//   若我们扫描不到，说明本就不可行。
// - 充分性：选择任一符合条件的窗口并执行减 1，保持 r 始终 ≥ 0，只减少需求；循环执行到结束即得到可行方案。
//
// 复杂度：对每个 k（n 个），扫描 O(n) 个窗口，每个窗口检查 O(k)，最坏 O(n^3)。在 n ≤ 100、t ≤ 100 的限制下完全可承受。
// 备注：尽管 p 是 1..n 的排列，这个算法只依赖初始值均 ≥ 1 的事实，而排列满足该条件。

#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; 
    cin>>T;
    while(T--){
        int n; cin>>n;
        vector<int> a(n);
        for(int i=0;i<n;i++) cin>>a[i];
        bool f = 1;
        vector<int> r = a;
        for(int k=n;k>=1;k--){
            bool found = false;
            for(int s=0;s+k-1 < n; s++){
                bool can = 1;
                for(int j=s;j<=s+k-1;j++){
                    if(r[j] <= 0){ can = false; break; }
                }
                if(can){
                    for(int j=s;j<=s+k-1;j++) r[j]--;
                    break;
                }
            }
            if(!found){ 
                f = 0; 
                break;
             }
        }
        cout<<(f?"YES":"NO")<<"\n";
    }
    return 0;
}
